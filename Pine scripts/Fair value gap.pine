// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© glenrutherford4

//@version=5
indicator("Fair Value Gap", overlay = true, max_boxes_count = 500)

fixedBoxLength = input.bool(true, "Fixed Box Length")
boxLength = input.int(3, "Box Length")
boxColour = input.color(color.new(#f6fa03, 60), "Box Colour")
boxLineColour = input.color(color.new(#f6fa03, 60), "Box Outline Colour")

largeFVG = input.float(0.00010, "Large FVG", step = 0.00001)

type fvg
    box   fvgBox
    float limit
    bool isBullish

var fvg[] fvgs = array.new<fvg>(0)

isBullish(i) =>
    close[i] > open[i]
isBearish(i) => 
    close[i] < open[i]

upperWickRange = isBullish(0) ? high - close : high - open
lowerWickRange = isBullish(0) ? open - low : close - low
candleRange = high - low

topWickSize = high - math.max(open, close)
bottomWickSize = math.min(open, close) - low

firstCandleIndex = 2
secondCandleIndex = 1
lastCandleIndex = 0

isOverLapPriorBar(int middleCandleIndex) =>
    fvgSize = 0.0
    // When middle candle is bullish or bearish, this assumes the candles either side continue in the same direction
    if middleCandleIndex >= 1
        previousCandleIndex = middleCandleIndex + 1
        nextCandleIndex = middleCandleIndex - 1

        isBullishMiddleCandle = isBullish(middleCandleIndex)

        // If there is overlap of previous and next candles then there is no gap to highlight
        isOverlapPrevNext = isBullishMiddleCandle ? low[nextCandleIndex] <= high[previousCandleIndex] : high[nextCandleIndex] >= low[previousCandleIndex]

        isTopBodyOverlapped = isBullishMiddleCandle ? close[middleCandleIndex] >= low[nextCandleIndex] : open[middleCandleIndex] >= low[previousCandleIndex]
        isBottomBodyOverlapped = isBullishMiddleCandle ? open[middleCandleIndex] <= high[previousCandleIndex] : close[middleCandleIndex] <= high[nextCandleIndex]

        if not isOverlapPrevNext and isTopBodyOverlapped and isBottomBodyOverlapped
            if isBullishMiddleCandle
                array.push(fvgs, fvg.new(box.new(bar_index - middleCandleIndex, low[nextCandleIndex], bar_index + boxLength, high[previousCandleIndex], bgcolor=boxColour, border_color=boxLineColour, border_width = 1), high[previousCandleIndex], true))
                fvgSize := math.abs(high[previousCandleIndex] - low[nextCandleIndex])
            else
                array.push(fvgs, fvg.new(box.new(bar_index - middleCandleIndex, low[previousCandleIndex], bar_index + boxLength, high[nextCandleIndex], bgcolor=boxColour, border_color=boxLineColour, border_width = 1), low[previousCandleIndex], false))
                fvgSize := math.abs(low[previousCandleIndex] - high[nextCandleIndex])
    fvgSize // return value

fvgSize = isOverLapPriorBar(1) 

//////////////////////////////
// Extend lines until they are crossed (by close)
// https://www.tradingview.com/pine-script-docs/en/v5/language/Loops.html
// https://stackoverflow.com/a/68733918
i_maxLineLength = 400

adjustBoxEnd(_array, stopExtensionOnCross, fixedExtensionLength) =>
    int _boxCount = array.size(_array)

    if _boxCount > 0
        for _i = _boxCount - 1 to 0
            fvg  _fvg = array.get(_array, _i)

            if stopExtensionOnCross

                bool  _fvgMitigated = (_fvg.isBullish ? low <= _fvg.limit : high >= _fvg.limit) and bar_index != box.get_left(_fvg.fvgBox) // ignore if start of box
                if _fvgMitigated or bar_index - box.get_left(_fvg.fvgBox) > i_maxLineLength
                    array.remove(_array, _i)
                else
                    // Extend right
                    box.set_right(_fvg.fvgBox, bar_index)
 
                    // Reduce box for partial mitigation
                    if(_fvg.isBullish and low < box.get_top(_fvg.fvgBox))
                        box.set_top(_fvg.fvgBox, low)
                    if(not _fvg.isBullish and high > box.get_bottom(_fvg.fvgBox))
                        box.set_bottom(_fvg.fvgBox, high)


                true    // don't need a return value but this fixes a return type error
            else
                box.set_right(_fvg.fvgBox, box.get_left(_fvg.fvgBox) + fixedExtensionLength)

                false    // don't need a return value but this fixes a return type error

////////////////////////////
adjustBoxEnd(fvgs, not fixedBoxLength, boxLength)

